#!/usr/bin/env python
# coding: utf-8

# Выполните следующие шаги:
# 
# Скачайте файл с предложениями (sentences.txt).
# 
# Каждая строка в файле соответствует одному предложению. Считайте их, приведите каждую к нижнему регистру с помощью строковой функции lower().
# 
# Произведите токенизацию, то есть разбиение текстов на слова. Для этого можно воспользоваться регулярным выражением, которое считает разделителем любой символ, не являющийся буквой: re.split('[^a-z]', t). Не забудьте удалить пустые слова после разделения.
# 
# Составьте список всех слов, встречающихся в предложениях. Сопоставьте каждому слову индекс от нуля до (d - 1), где d — число различных слов в предложениях. Для этого удобно воспользоваться структурой dict.
# 
# Создайте матрицу размера n * d, где n — число предложений. Заполните ее: элемент с индексом (i, j) в этой матрице должен быть равен количеству вхождений j-го слова в i-е предложение. У вас должна получиться матрица размера 22 * 254.
# 
# Найдите косинусное расстояние от предложения в самой первой строке (In comparison to dogs, cats have not undergone...) до всех остальных с помощью функции scipy.spatial.distance.cosine. Какие номера у двух предложений, ближайших к нему по этому расстоянию (строки нумеруются с нуля)? Эти два числа и будут ответами на задание. Само предложение (In comparison to dogs, cats have not undergone... ) имеет индекс 0.
# 
# Запишите полученные числа в файл, разделив пробелом. Обратите внимание, что файл должен состоять из одной строки, в конце которой не должно быть переноса. Пример файла с решением вы можете найти в конце задания (submission-1.txt).
# 
# Совпадают ли ближайшие два предложения по тематике с первым? Совпадают ли тематики у следующих по близости предложений?

# In[415]:


import re
from scipy.spatial import distance
import numpy as np

file = open('C:/Users/kruzh/Downloads/sentences.txt', 'r')
str = file.read().lower()
arr = re.split('[^a-z]', str)
line = str.split('\n')
arr = [x for x in arr if x]
words = {}
num = 0
for word in arr:
    if word not in words:
        words[word] = num
        num += 1

for j in range(len(line)):
    i = 0
    for word in words:
        matrix[j][i] = 0;
        for w in re.split('[^a-z]', line[j]):
            if w == word:
                matrix[j][i] += 1
        i += 1

r_array = [scipy.spatial.distance.cosine(matrix[0], matrix[l]) for l in range(0, len(line))]
s_array = sorted(r_array)

print (r_array.index(s_array[1]), s_array[1])
print (r_array.index(s_array[2]), s_array[2])


# f(x) = sin(x / 5) * exp(x / 10) + 5 * exp(-x / 2)
# 
# Сформируйте систему линейных уравнений (то есть задайте матрицу коэффициентов A и свободный вектор b) для многочлена первой степени, который должен совпадать с функцией f в точках 1 и 15. Решите данную систему с помощью функции scipy.linalg.solve. Нарисуйте функцию f и полученный многочлен. Хорошо ли он приближает исходную функцию?
# 
# Повторите те же шаги для многочлена второй степени, который совпадает с функцией f в точках 1, 8 и 15. Улучшилось ли качество аппроксимации?
# 
# Повторите те же шаги для многочлена третьей степени, который совпадает с функцией f в точках 1, 4, 10 и 15. Хорошо ли он аппроксимирует функцию? Коэффициенты данного многочлена (четыре числа в следующем порядке: w_0, w_1, w_2, w_3) являются ответом на задачу. Округлять коэффициенты не обязательно, но при желании можете произвести округление до второго знака (т.е. до числа вида 0.42)
# 
# Запишите полученные числа в файл, разделив пробелами. Обратите внимание, что файл должен состоять из одной строки, в конце которой не должно быть переноса. Пример файла с решением вы можете найти в конце задания (submission-2.txt).
# 

# In[27]:


import math
import scipy
import numpy as np
from scipy import linalg

def f(x):
    return math.sin(x / 5) * math.exp(x / 10) + 5 * math.exp(-x / 2)

def a_matrix(xs):
    matrix = [[x**n for n in range(len(xs))] for x in xs]
    return matrix
 
def b_matrix(xs, f):
    matrix = [f(x) for x in xs]
    return matrix
 
points = [(1, 15), (1, 8, 15), (1, 4, 10, 15)]

for x in points:
    a = a_matrix(x)
    b = b_matrix(x, f)
    solve = scipy.linalg.solve(a, b)
    print(solve)

